id: 92ae5df0b2
标题：马克思的数学手稿（续）
日期：1881-0-0
是否是时间段：false
作者：马克思
来源：
标签：
书籍：自然辩证法一九七四年第三期
书籍作者：恩格斯，人民出版社1971年版

正文：
马克思的数学手隔（续

微分演算的历史发展过程

1）神秘的微分演算。=+4，一开始就变为=+da或+，其中da是通过形而上学的解释来假定的。先是存在，然后对它进行解释。

于是也就有=3+dy或y=+9。从这个任意的假定，就得出这样的结论：为了得到正确的结果，我们在二项式+4或+的展开中，必须把例如与一阶导函数一起获得的、用和4表达的那些项魔术般地丢掉，等等，等等。由于在实际建立微分演算的时候，是从上述结果出发的，也就是从那些预料到的、不是推导得来而是用解释来假定的微分元出发的，所以符号

dy或y也是为这种解释所预料到的。微系数或也是为这种解释所预料到的。

如果的增量=4，而依赖于它的变数的增量=4y，那末

Ay表示和的增量之比。至于4出现在分母中，不言而喻，436表示和的增量之比。至于4出现在分母中，即自变数的增量出现在分母中而不是反过来出现在分子中，这是因为微分形式演化的最后结果本身，即微分，也是一开始就由那些假定的微分元所给定的缘故。

如果我取因变数？和自变数的最简单的关系，即=，那①马克思在*论微分手稿中曾指出，接下去要论述“微分演算的历史发展过程”。这次继续刊登的就是这方面的部分手稿内容，包括：微分演算的历史发展过程，初稿*，续稿*和《达兰贝尔方法分析*。末我知道dy=dc或！=。但是由于我要找自变数的导函数，在这里它=，所以我必须用或d去除两边，因而

ay

3

一或亲=1。所以我一下子就全都知道，在符号微系数中自变数的增量必须出现在分母中而不是出现在分子中。

但从的二次幕函数开始，用二项式定理就立刻可以找到导函数，这个导函数完全现成地出现在第二项中，并伴随着d或，即一次靠的增量，加上要魔术般地丢掉的各项。这种魔术般地丢掉虽不自觉但在数学上是正确的，因为它只是丢掉了由最初的魔术一开始就产生的那个计算误差。

把=+4变为

2=3+da或3+于是对这微分二项式就可象对普通的二项式一样进行处理，从技术观点来看，这是很有成效的。

唯一还可能提出的问题是：为什么把那些碍手碍脚的项用暴力镇压掉？这就是假定大家都已经知道它们是碍手碍脚的，并且实际上不属于导函数。

回答很简单：这纯粹是从经验得来的。不值对许多更加发展了的的函数，以及作为曲线方程的它们的解析形式等等，人们早已知道了实际的导函数，而旦就在最先可能的决定性试验中，即在对最简单的二次代数函数的处理中发现了这一点，例如：

9=a²，y+ay=(+da)²=²+2ad+d²

3+y=（+）²=a²+20+²。如果两边都减去原来的函数a*（y=*），那末dy= 2ada+da²

9=2+如果我从两个式子的右边镇压掉最后一项，那末

dy=2ada，9=20，进而得到

dy_=20，

dao或

=200。

富

但是从（+a）*知道，是第一项；第二项是2g；如果我用去除这表示式，犹如用da去除上面的2ada，或者用去除2，那末得到2作为的一阶导函数，作为二项式给添加的用表达的增长。因此，为了找出导函数，必须把d或镇压掉：而根本不管d或本来是无可奈何的。

所以，人们通过试验的方法—就在第二步中—必然会认识到：不但为了得到一个正确的结果，甚至为了得到任何一个结果，都必须把da或魔术般地丢掉。

其次，人们已在

2ada+dx²或20+中看到，它们是二项式（+d）或（+）*的正确的数学表示式（第二和第三项）。至于这个数学上正确的结果建立在数学上根本错误的假定之上，即一开始就把-=4当作2-=d或，这是人们所不知道的。不然的话，人们不用魔术般地丢掉而用最简单格式的代数运算也会获得同样的结果，并把它提供给数学界。

所以，人们自己就相信了这种新发现的算法的神秘性质。这种算法用数学上肯定是错误的方法得出了正确的（尤其在几何应用中惊人的）结果。这样，人们就把自己神秘化了，越加高估这个新发现，也就越加引起了一群旧式正统派数学家的恼怒，并激起了敌对的叫露，这种叫露甚至在数学界以外得到了共鸣，而这也是为新事物开拓道路所必需的。

2）理性的微分演算。达兰贝尔直接从牛顿和莱布尼茨的出发点：=+d开始。但是他立刻做了一个根本的修正=+4，也就是给加上一个不确定的，但初看起来是有限的增量，他把这个增量叫做h。而这个h或4变为d（他和所有法国人一样，都采用莱布尼茨的写法），只是作为演化的最后结果，或者至少发生在最后一刹那之前，但神秘主义者和这种演算的创始者，却把它作为出发点（达兰贝尔本人是从符号的一边出发的，然而是在这一边变为符号之前出发的）。这样就立刻得到两种结果。

a）构成差值之比

f（+h)-f（)f（a+h）-f（①）

h

313的出发点是

1）f+h）-f（），它相应于一个用给定的代数函数，这个代数函数是在用步表达的原函数例如中，以和它的增量即+h代替而得出的。这种形式（如果=f），它就=3一）是函数差值的形式，为了变成函数增量对自变数增量的比值，这种形式还需要进行演化，因而它起着实在的作用，不象在神秘主义者们那里仅仅起着有名无实的作用；因为，如果我象这些人那样有

f（①）=3²

f（+h)=（+h)==+3x²h+3xh²+h²那末我开始就知道，在

f（x+h）-f（）=x²+3x²h+3xh²+h²-x²中对立着的两边，都已归结为增量。这甚至不必写出来，因为我在右边已看到的增量=其后面的三项，同样在f（+h）-f（）中剩下的只是f）的增量或dy。因此，这个最初的差值等式只起着一开始就重新消失的作用。这些增量一开始就处在对立的两边，如果我有了它们，那末从da，dy的定义我就得出dy

1心或是是比值等等，所以为了形成dy或，

，我用不到从（以+

品或金代替）变化了的函数（增长了的函数）中减掉用表达的原函数而形成的那个最初的差值。

在达兰贝尔那单必须抓住这个差值，因为演化运动要在它身上进行。所以，在左边处于突出地位的就不是差值的肯定表示式、即不是增量，而是增量的否定表示式，即差值，也就是f（+h）-f<a）。这种强调差值而不强调增量（牛顿的流数）的做法，至少在莱布尼茨所用的、与牛顿的相对立的写法@中已经预感到了。

2）f（a+h）-f（x）=3x²h+3ah²+h²。用h去除两边，便得

f（x+h)-f（x）=3²+3xh+h²。

h由此，在左边形成了

f（x+h）-f（)f（x+h）-.f（x）

h

3-3它（本身）就显现为导出的有限差值的比值，而在神秘主义者们那里，它是由d或和dy或！的定义所给出的增量的现成的比值。

3）现在，如果在f（g+h）-f（①）f（3+h）-f（x）

A

3一3

d中令A=0，或z=，即2-=0，那末这表示式就交为丽由于令h=0，3ah+h这两项也就同时变为0，并且确是通过正确的数学运算得到的。所以现在不用魔术就把它们消除了。我们得到：

0dy=3x²=f²（)。4）或游=3x²=f²（)。

一旦变为+h，这个式子就同在神秘主义者们那里一样，已作为给定的东西存在了，因为（+h）代替”而给出了*+3²h+etc.，其中3*已经在这个展开级数的第二项中作为一次幕的系数出现。因此，这种推导本质上与莱布尼茨和牛顿相同，但是这个完全现成的导函数3是用严格的代数方法从与它相联系的其余各项那里解脱出来的。这不是演化，而是把f（），在这里就是3*，从它的因子h以及与它排在一起的其余各项那里解脱出来。而实际上演化的，倒是在左面符号一边，就是dx，dy和它们的比值，即符号微系数=（反过

dy0

（反过

ody更为怡当）。这个符号微系数本身还是引起了某来，=a更为怡当）。这个符号微系数本身还是引起了某些形而上学的恐俱，尽管这个符号是用数学方法导出的。

达兰贝尔给微分演算撕下了神秘的外衣，从而向前迈进了一大步。虽然他的《流体论》已于1744年出版（参见15页①）但菜布尼茨的方法很多年来仍然在法国占着优势。至子牛顿的方法在英国一直统治到十九世纪的买几十年，这凡乎是没有必要提及的。但是在这里，正象以前在法国一样，达兰贝尔奠定的基础，经过一些修改，一直到现在还占着统治地位。O见本文第10页。

3）纯粹代数的微分演算。拉格朗日，《解析函数论》（1797年和1813年）。因此在1）中和在2）中一样，最初的出发点都是增长了的，如果

或f（）=etc.，那末在神秘的方法中是或f+da），在理性的方法中是或f（+h）（=f（+））。这个二项式出发点立刻在等式的另一边提供了一个二项式展开，例如

a+m*-h+etc.这里的第二项m*-*h已完全现成地提供了所要找的实在微系数m”。

3）在给定的的原函数中，当用w+h代替时，左边的f+h）和它对面的展开级数的关系，完全象代数中未展开的一投表示式，尤其是二项式，和与它对应的展开级数的关系一样，例奶，象在

（a+h）=²+3²h+etc中，（+h）*与其等价的展开级数+3a²h+etc.的关系一样。因此，f+h）就处于同在整个代数学中一般表示式与其展开式的关系一样的代数关系（只应用于变量）之中，例如，同在

a²°号

二1+好

23+a+etc.8一3

8

G中，0-3与展开式1+etc.一样的关系之中；或同在

sin（x+h）=singcosh+cogasinh中，sin（+h）与其对面的展开一样的关系之中。

达兰贝尔仅仅把（+d）或（+）代数化了，使之变为（w+h），因而f（g+h）也从y+dy,y+g变成了f（x+h）。但是，当拉格朗日把整个表示式作为一般的未展开的表示式，放在从它导出的展开级数对面时，他就给了这整个表示式一个纯粹代数的性质。

b）在第一个方法1）中和在理性的方法2）中一样，所要找的实在系数都是完全现成地由二项式定理产生出来的，而且已经出现在展开式的第二项，也就是必然附有A的一项中。因此，整个往后的微分过程，无论在1）或者在2）中，都是奢侈品。所以我们把这无用的压舱物抛在一边。从二项式的展开中我们一下子就全都知道，一阶的实在微系数是的因子，二阶的是h²的因子等等。这些实在微系数无非是用表达的原函数依次按二项式展开的导函数（而引进导函数这一范腾是最重要的引进之一）。就各别的微分形式而论，我们知道4变为da，4y变为dy.

dy知道一阶导函数得到符号形象，二阶导函数，即去的系数

2

Cy等等。因此，为对称起见，我们可以把这些纯得到符号形象等等。因此，为对称起见，我们可以把这些纯粹用代数方法得到的结果同时也用它们的符号微分等价物来表示——这是微分演算本身唯一遗留下来的名称问题。整个实际的课题于是就化为寻找（代数）方法，“把+h的各种函数按的整数升靠加以展开，而在许多情况下，没有非常觉长的运算这是不可能完成的”。

到此为止，在拉格朗日那里没有什么直接从达兰贝尔方法出发不能得到的东西（因为这方法也包括了神秘主义者们的整个演化，不过是以修正的形式要了）

c）因此，当的展开或f（w+h）=etc.代替以前的微分演算的时候[这样一来，事实上清楚地暴露出了从

3+dy或+g，+dw或十出发的那些方法的秘密，即它们的实际演化是以二项式定理的应用为基础的，因为它们一开始就对增长了的用+da，增长了的3用y+dy来表示，从而把单项式变为二项式]①，就会有这样一个课题：由于f（+）在这里是没有幕次的的函数，只是它的一般的未展开的表示式，所以要从这个未展开的表示式自己，用代数方法把一般的，因而也就是对任何幕次的的函数都适用的展开级数推导出来。

为了把微分演算代数化，拉格期日用了车顿学派以及车顿生前的泰勒的定理作为他的直接出发点。这个定理实际上是最一般最概括的定理，同时也是微分学的运算公式，即用符号微系数表示的或f（+h）的展开级数，亦即

或f（+h）=y（或f（））+dh+

d²yh²d²ynd²yh

+a3]+23.+ec。dad）这里要插进对于麦克劳林和泰勒定理的研究。e）拉格朗日用代数方法把f（+h）展开成等价级数，代替

头等等，并且只让它们作为用代数方法导来的多的函泰勒的数的符号微分表示式而存在。（这一点以后再详细讨论。）①这对括号是在马克思的手稿里原来就有的。

初稿

牛顿：1642年生，1727年死（85岁）。《自然哲学的数学原理》（1687年初版，参见引理1和引理X1，注释）。

而后特别是《使用级数，流数的分析·.》，1711年第一次出版，但在1665年已经完成，而莱布尼茨于1676年才获得同样的发现。

莱布尼茨：1646年生，1716年死（70岁）。

拉格朗日：1736年生，带制时期（拿破仑一世）才死，变分法的发明者。《解析函数论》（1797年和1813年）

送兰贝尔：1717年生，1783年死（66岁）。《流体论》，1744年。

）牛顿。速度或流数，例如，3等变数的速度或流数，用，等表示。例如，若和是由连续运动所产生的相互联系

七就是它们的的量（流量）；则和表示它们的增长率，因此让增量据以生成的增长率之间的比值。

由于各种各样的量的数值都可用直线表示，所以瞬或者生成量的无限小部分=它们的速度和这些速度所经历的无限小时面间隔的乘积，因此如用表示这无限小的时间间隔，那末少和3的瞬就分别用和来表示。

例如=z若，分别表示3.z，增长的速度，则，，的瞬便是T，t，t，于是我们得到：

y=gz,y+Tg=（u+tu）(2+T）=2+T+2Tu+T²u因此

Ty=uta+ztt+t²ua.

由于无限小，所以它会自行消失，就更不用说作为乘积的了，这不是出于无限小的时间间隔，而是它的2次方。

1

1假如=-百方，那末t²=

百万×百万因此我们得到

y=tx+v，或者说=z的流数是z+a。

2）莱布尼茨。假定要我的是z的微分。变为+du，2变为2+dz因此2+d(2)=（+da)(2+dz)=ax+dz+zdu+dhidz。

如果我们从这式子中减去给定的量2，那末剩下来的是作为增量的adz+zdu+dadz；由无限小的da乘上另一个无限小的dz组成的乘积dud，是一个二阶无限小，它的消失将先于一阶无限小adz和zda，所以

d（az)=d2+zdu。3）达兰贝尔。一般这样来提问题。设

2=f（x），

3=f（0+h）要确定：当A这个量消失时，之的值将变为什么，也就是说，

h0的值将变为什么。0的值将变为什么。

牛顿和莱布尼茨，以及他们的大多数继承者，一开始就在微分演算的地盘上活动，因此微分表示式一开始就当作尔后去找实在等价物的运算公式。全部奥妙就在于此。如果自变数变为，那末因变数就变为9.但是-必然等子某个差值，例如=h。这包含在变数概念本身之中。然而决不能由此得出这样的结论：这个=d的差值是消失着的，因而事实上就=0。它也可以表示一个有限差值。可是如果我们一开始就假定，当增长时它变为+（牛顿的在他对基本函数的分析中不起任何作用，所以可镇压掉），或者象莱布尼茨那样，变为+d，那末微分表示式就立刻变为运算符号，而没有显示出它们的代数起源。

补充150（牛顿）。

对要进行微分的乘积z，如果我们取牛顿的起始等式，那末：

y=z，

3+Tg=（g+x)(2+2T）。

如果我们丢掉，就象牛顿在展开第一个微分等式之后自已所喜欢做的那样，便会得到：

3+g=（g+a)（2+2）+=az+++a

3+y-x=+au+。因此，由于2=3，

y=z+xu+aa。并且为了得到正确的结果，必须把镇压掉。

那末这个要用暴力去镇压掉的项是从哪里来的呢？

非常简单，是这样来的：的微分？，的微分和2的微分，一开始就是通过定义，当作与产生它们的那些变量相分开的、独立的存在而引进来的，并不是用任何一种数学方法推导出来的。

我们一方面看到，这种预先假定dy，或，的存在具有①指论微分>底稿中的页码。什么样的好处：一且变数增长，我只须一开始就把二项式？+！，+等代入代数函数中去，就可以把它们作为普通代数量来处理。

例如当=aa时，我便得到

3+9=a+a从市

3-a3+3=a元因此

y=a。

这样，我立刻就得到下面的结果，因变数的微分等于a的增长，即，也就是等于从a导出的实在值（至于它在这里是个常数，那是偶然的，一点也不影响所得结果的普遍性，因为出现这种情况，只应归之于变数在这里是一次暴）乘上。如果我把这结果加以普遍化，那末我知道=f），因为它表明3是一个依赖于的变数。如果我把从f）导出的量，也就是增量的实在元素叫做f（），那末一般的结果便是

=f²（x)。

因此我一开始就知道，因变数？的微分的等价物，等于自变数的一阶导函数乘上它的微分，即乘上da或。

所以一般地说，如果

y=f（a），那末

dy=f（a）da或者=用表达的实在系数（除了因处于一次靠而出现常数的情况外）乘上。

但=立刻给了我

心=，而在一般情况下，9

=f²（）。

这样，我就给微分和微系数找到了两个进一步发展了的运算公式，它们构成了整个微分演算的基础。

此外，一般说来，由于我把先验地①假定的d，等，或，等，当作和的独立的、孤立的增量而得到了微分演算所特有的极大好处，这就是说，变数的一切函数从一开始就可以用微分形式来表示

如果我用这种方法对变数的一些主要的函数，如a，a士

黄b，23，，”，，10g”，以及初等的圆函数进行了推导，那末当

dy时，我就完全可以象算术中的乘法表那样来利用要找dy，da时，我就完全可以象算术中的乘法表那样来利用它们。

但是，如果我们现在看一下事情的反面，那末我们立刻发现，原先的全部运算在数学上都是错误的。

我们举一个非常简单的例子：=²。如果增长，那末它就得到一个不确定的增量，因而依赖于它的因变数？也得到了一个不确定的增量，于是我们有

y+k=（a+h）²=a²+2hx+h²这是由二项式定理给我们的一个公式。因此

+h-²或3+k-y=2ha+h²所以

（y+k)-y或k=2ha+h²，如果用h除两边，那末

k=2a+h。

h①“先验地”一词，原文为apriori。现在令h=0，就得到

20+h=20+0=20。但另一方面，却变为店

k却变为店

：又由于仅当多变为2+h时才变为+k，所以当h变为0，因而+h文变为+0，即变为时，+k重新变为9。因此，B也将变为0而点=

0=，这可用a

台成是

0如果我们不这样做，而在

y+h-a²=2ha+h²或（y+k)-y=2ah-h²中令h=0（h只有事先在它的原来形式中被置为0之后才变为符号da），那末得到=0+0=0，而我们所获得的唯一结果，是看清楚了我们的假定：当变为+h时才变为y+，….所以当+h=+0=时，+=，或者=0。

但是我们绝不会象牛顿所做的那样得到，

k=2xda+dad或者按牛顿的写法得到

9=20%+只有当经历了通过0的地狱之行以后，也就是说，在-（或（+h）-）这个差值，因而g-3（=（y+）-）这个差值也被减少到它们的绝对最小表示式-=0和-=0以后，才能化为金，从而&化为！。

但由于牛顿不是用数学推导来确定变数，9等的增量，而是立刻给它们打上了微分，9等的标记，这些增量就不能=0否则结果势将为0，因为用代数表达的话，一开始令这些增量

5=0，就象上面在等式

（y+k)-y=2ah+h²中立刻令h等于0，所以k=0，从而最终就会得出0=0。在用除法便的一阶导函数，即这里的20，从因子那里解放出来之前，也就是在获得

9-9=2x+h

h之前，是不允许把h等于零的。只有在这以后，有限差值才能被扬弃。因此在我们能够获得微分

dy=2ada之前，原来就必须先导出微系数

d.=2。

da

所以没有其他办法，只有把变数的增量A想象为无限小增量，并赋予它们以独立的存在，例如在，或d，y等符号中那样。然而，无限小量和无限大量一样，也是量（无限这个词实际上只意味着不确定地小），因此这些dy，d或，等在计算中也起着和普通的代数量一样的作用，并且在上述等式

（3+k）-或k=2d+dacda中，dada具有和2ad一样的存在权利。但是最使人惊奇的是电暴方把它镇压掉的那个理由，恰恰在子利用了无限小概念的相对性。dada要镇压掉，因为它与da相比，从而也与2ada或与20相比是无限小.…..

或者，如果在

y=2++中，由于与和c相比是无限小而被镇压掉，那末在数学上只能这样来补救，那就是认为z+au.是人们愿意怎样逼近就能怎样通近的一个近似值。这种处理方法在普通代数里也会遇到。但这时就出现了一个更大的奇迹，即通过这种方法得到的，绝不是用表达的导函数的近似值，而是它的严格的准确值（尽管象上面那样只是符号上正确的），象在

9=20+这个例子中那样。如果我们在这里镇压掉珑，那末就得到

9=23和

=23，

店正如二项式定理已经表明的那样，这是由正确地导出的第一个导函数。

但这奇迹并非什么奇迹。如果通过暴力镇压掉而得不出准确的结果，那倒真是奇迹了。因为镇压掉的只是一个计算误差，而它却是这样一种方法不可避免的结果，这种方法把变数的不确定的增长，例如，立刻作为微分或，作为现成的运算符号引了进来，从而在微分演算中一开始也就获得了一个独特的、不同子普通代数的计算方法。

我们所应用的代数方法的过程，一般可以表述如下。

设给定f（），那末首先演化出“预先导函数”，我们称之为f²（2）

y=f²（x）。

器，或器1）

F²（3）=Ay从这等式得出；

Ay=f²(a）a。因而也得出

4f（)=f²（a）Aa（因为3=f（），4y=4f（））。

通过令-=0，因而:-y=0，我们得到

0于是

dy=f²（）da所以也得

af（a)=f²（①）da（因为y=f（a），dy=df（a））。

如果我们一且演化出1

Af（)=f²（3）4x那末

2）

df（a）=f²（a）da不过是1）的微分表示式而已。

1）如果变到，那末

A）-=As由此得出下列结论：

Aa）4=-3；

a）-Aa=s所以，4这个和之间的差值被肯定地表示时，它是的增量：因为当重新从中减去它时，就回到原来状态，即回到了a。

因此，这个差值可用两种方式来表示：直接作为增长了的变数与其增长前的状态之间的差值，这是它的否定表示式；肯定地把它作为增量①，作为结果、作为对于尚未增长时的的增9马克思在这里用铅笔加了“或减量”这几个字。量，这是肯定表示式。

我们将会看到，这种双重解释在微分演算历史中起了什么样的作用。

b）a=3+Ax。

是增长了的本身，的增长没有和它相分开：是增长的完全不确定的形式；这形式把增长了的，即，向增长前的原来形式区别开来，但是这形式并没有把同它的增量本身相区别。因此，和之间的关系只能香定地作为差值，即作为-来表示。与此相反，在

0，=+a中：

1）差值是肯定地作为的增量来表示的。

2）因此的增长不是作为差值，而是作为处在原来状态中的本身+它的增量的和式来表示的。

3）从技术上来表述时，将从单项式变为二项式，凡是原函数中有的任何基次出现的地方，都要用自己和它的增量组成的二项式来代替增长了的，一般地说，用二项式（+h）”来代替。这样，的增长的展开事实上就是二项式定理的简单应用。由于在这个二项式中是第一项，是第二项一一这是由它们的相互关系本身所给定的，因为在增量4产生之前就必须存在一—所以事实上用二项式只是导出了的一些函数，而4则以升幕方式出现在它们的旁边作为因子，并且4的一次幕即4，应该是展开级数第二项的因子，即由二项式定理导出的的一阶导函数的因子。当以二次幕给定时，就立刻可以看出这一点。²将变为（+）*，这无非是（+4）和它自己相乘而绘出²+24+²。这就是说，的原函数应该是第一项：的一阶导函数，即这里的2，和因子4²一起构成第二项，而在第一项中4仅以4°=1的形式出现。所以导函数不是通过微分而是通过应用二项式定理即通过乘法找到的，并且正是因为增长了的本身一开始就表现为二项式+4的缘故。

4）虽然在+4中，4就其大小而言是不确定的，象不确定的变数自己一样；但是4作为与有区别的、与之相分离的量又是确定的，如同胎儿与怀孕前的母亲并列着一样。

+4不只是不确定地表明作为变数有所增长，而且它表明增长了多少，即增长了4。

5）从不显现为当应用二项式定理，也就是把+4m代入的一定暴次中而找到导函数的时候，那末整个演化就围绕着增量4进行。只是在左边，当当元中的4变为

40

A=0时，它最终又以=，一的形式出现，以致

3-y3-94y406

313

4x1

所以-=0这样肯定的一边，即变为=，决不能在演化中出现，因为本身决不会出现在展开级数的一边；这样，微分演算的真正秘密也就决不会暴露出来。

6）如果=f（c）且=f（x+4），那末我们可以说，在这个方法中y的展开解决了找导函数的问题。

c）+=a（因而y+Ag=y）。4在这里只能以4=-的形式出现，也就是以和的差值这种否定形式，而不是象在：=+4中那样作为的增量那种肯定形式出现。

1）在这里，增长了的，即，有别于增长前的它本身，即有别于，但并不是作为增长了4的而出现的：因此，实际上完全象一样是不确定的。

2）再者：正象出现在一个原函数中一样，作为增长了的也就出现在由于这个增长而变化了的原函数中。例如出现在函数中时，就出现在函数中。以前，在原函数中有出现的地方，都用（+4）来代替，从而由二项式定理完全现成地得出了导函数，尽管这个导函数附有因子4，而且是作为附有0²等因子并用表达的其他各项的先行者出现的；而现在，从破也就是从增长了的的单项式这一直接形式中，就象从”中一样，是直接推导不出什么的。但是由此给出的是差值一*。我们从代数学知道，所有形如*-a的差值都可用（x-a）除尽，在现在的情况中就是可用（-）除尽。所以用-0去除-*（而不是象以前那样让（+4）按函数的给定幕次自乘若干次），我们就获得一个形如（-）P的表示式，不管的原函数是多项式（即含有的不同靠次），还是象在我们这例子中那样是单项式，在这里都不会有什么改变。通过除法，这个（x-）变为左边y-y的分母，因而产生了二这个用抽象

30:一3的差值形式表示的函数的差值和自变数的差值之比。要把用表达的函数和用表达的函数之间的差值分解成都含有（-）作为因子的各项，就要根据的原函数的性质，或多或少用到一些代数技巧，不会总是象在-*中那样容易。但这在方法上并没有什么改变。

凡是原函数按其性质不能直接分解为（，-）p的地方，如f（）=az（两个依赖于的变数）就是这样，（：-a）便出现在因子元元中。再者，用（a-a）去除两边面在左边把它消掉以

T-④后，如果在P中还保留有：-2的话（例如对y=a*求导时，我们求得2-2=a²（c-1）+（x:-30）-1

（a1

1.2

3:-3若在这里令-=0，则得

2（aT38（（a-1）

etc二

门

上

2那末象在刚才引用的例子中那样，总是只能这样做：通过令一2=0来使它消失，从而在它的位置上总会留下一个肯定的结果。换一句话说，在P中还保留下来的一是不可能作为因子（作为乘数）与P的其他成份联结在一起的。不然的话，就可把P分解成P=p（-），而由于已令-=0，它就变成.0因而P=0....

如果=从而=，那末一阶有限差值-°就演化成

3:-y=（3:-3)P于是

y-9=P。

第一8P这个由和组成的表示式=产，也就是一阶有限差值的导函数，其中-象高次幕（-a）”等等一样已被消去。因此

如文z和2只能结合在象+，，，√.等等这样一些肯定的表示式中。所以如果现在令=，那末这些表示式就相应地交为，一

或1，√c或等等，而只是在-作为分母的左边才出现0，因而才出现符号微系数等等。

续稿c）续25页①。

我们原先把-=40当作差值-的表示式；这个差值在这里只是在它的形式上作为差值而存在（正象当为的因变数时，通常都写成y-y）。通过令-a=4，我们就给了这个差值一个与它本身不同的表示式。即使用的是不确定的形式，我们还是把这个差值的数值作为与这个差值本身不同的量来表示。例如4-2是4和2的差值的纯粹表示式：但是4-2=2是用（右边的）2表示的差值：a）因而在肯定的形式中，它已经不再作为差值；b）当减法已做完，差值已算出，4-2=2就给我提供了4=2+2。第二个2在这里以原来的2的增量的肯定形式出现，因而直接以一个与差值形式相对立的形式出现。（正如a-b=ca=b+c，其中C表现为的增量；又如-=，=+4，其中4直接表现为的增量。）

原先仅仅设置-=4=某个东西的做法，也就设置了代替差值形式的另一个形式，即和的形式工=+4，简时把只表示差值的-看作是这个差值的，即量4的数值等价物。

同样，从-=4m可以得到-4=。这里，我们在左边又有一个差值形式，但这是作为增长了的，和它自己的、独立地出现在它旁边的增量之间的差值形式。和的增量4之间的差值是这样的一个差值，它虽然不确定，但现在已表示的一个确定值。①指微分演算的历史发展过程初稿中的页码，相当于本文第17页。

然而如果从神秘的微分演算出发，在那里-立刻以-w=d的形式出现，又如果一开始就把da修正为，那末这就是从-=4出发，因而也就是从=+4出发，但是这式子本身又可以转变为+=，以致的增长又获得不确定的形式，而且作为这样的增长直接出现在微分演算中。这就是我们所应用的代数方法的出发点。

d）从这些简单的形式上的差别，立刻产生了对待微分演算的一个根本差别。这个根本差别，我们在分析达兰贝尔方法时已经详细指出（见所附的几张活页）、这里只是一般地作些评述。

1）如果差值-（因而-3）立即作为它的对立物，作为和式=+4出现，因而其数值大小立即以增x的肯定形式出现，那末当在用表达的原函数中处处以+4代替时，就要展开一定幕次的二项式，而，的演化便变为二项式定理的应用。二项式定理无非是一次的二项式自乘m次后所给出的表示式的一般表述。因此，如果我们一开始就把差值表示为它的对立物，即表示为和式，那末乘法就成了（即+4m）的演化方法。

2）由于在一般的表示式=+4中，处于肯定形式4，即增量形式下的差值-是这表示式的后一项或第二项，所以，一旦用表达的原函数换成用+4表达的函数，就是它：的第一项而4是第二项。但是我们从二项式定理知道，这第二项伴随着第一项只表现为升幕的因子，表现为乘数，因而用表达的（由二项式的暴次决定的）第一个表示式的因子是（）°=1，第二项的乘数是（4w）²，第三项的是（4）²等等。因此以增量的肯定形式表示的差值，只是作为乘数而出现，而且是在二项式（+c）展开的第二项中（由于（4w）°=1）第一次实际上作为乘数而出现。

3）另一方面，如果我们现在来看用本身表达的函数的展开，那末二项式定理就为这里的第一项，给我们提供了一连串导函数。例如，如果我们有（+h）*，在这代数二项式中，h是已知量，是未知量，那末我们得到

+4c²h+etc.因此，处于第二项中的、并以h的一次靠为其因子的4°，是的一阶导函数，或者用代数方法来表述：如果我们有二项式（x+h）的未展开的表示式，那末它的展开级数给我们提供了4c作为*的第一个增长（作为它的增量），它作为h的系数而出现。但如果是个变量，且我们有f（）=，那末这函数将由于它的增长本身变为f（+h），或者在第一种形式下变为

f（a+A）=（+)*=x*+40²a+etc.。在普通的代数二项式（+h）*中，*是作为这二项式的第一项给出的：而在变数的二项式表示中，亦即在（+）*中，这现在就显现为增长并且变为+4之前用表达的原函数的再生产。由二项式定理的本性，我们一开始就很清楚，如果f（）=*变为f（+h）=（+h），那末（+h）*的第一项等于*，亦即必须=用表达的原函数；（+h）必须包括两部分，即用表达的原函数（这里是*）+因*变为（+h）*而得来的一切附加项，因此二项式（+h）*的第一项·....

4）再者，二项式展开的第二项4*h立刻完全现成地给我们提供了*的一阶导函数，即40°。所以这种推导是通过

f（a+a）=（+Aa）²的展开而获得的，是通过把差值：-一开始就表示为它的对立物，表示为和式+4而获得的。

所以由于增长而从fw）获得的f（+4）或的二项式展开，给我们提供了一阶导函数，它是（二项式级数中）的系数，而直就在二项式展开的开头，即在其第二项中。因此，这种推导决不是通过取差值得来的，而是直接通过把f（+h）或展开成一个确定的、由简单乘法产生的表示式而得来的。

因此这方法的关键，在于把不确定的表示式或f（+h）展开成确定的二项式形式，而绝不是把w-，从而也不是把-或j（+h）-f（）作为差值来加以展开。

5）由于我们立刻得到f（+4）=（+Aa）*=0²+40²4+60²a²+404²+A²所以这方法中出现的唯一的差值等式，如果我们把它写下的话，就是

0+40²4+6x²²+4²+A²-²也就是把级数开端的原函数在后面重新减掉，于是在我们的面前就出现一个增置，它是用表达的原函数通过二项式展开而得到的。因此牛顿也是这样写的。所以我们得到增量

404+6²4²+404x+A²即原函数的增量。因而我们在对立的一边就不需要任何一种差值了。当

3或f（）=a时，相应于的增量有的增量。因而牛顿也立刻写为：

dy，在他那里是！=4*+ctc.。

6）此后的整个演化，就在于把完全现成的导函数4a从其因子4和各相邻项那里解放出来，从其环境中摆脱出来。所以这个方法不是演化法面是解脱法。

e）（作为一般表示式的）f（x）的微分

首先我们指出，“导函数这个概念作为符号微系数的逐次实在等价物，是微分演算原先发明人及其最初继承者们所完全不知道的，事实上首先是由拉格朗日引进的。在前者那里，只有因变数例如3才显现为的函数，它完全相应于函数的原来代数意义，这种函数最初用于未知数多于方程个数的那些所谓不定方程，所以在那里随着取不同的值，例如？也就取不商的值。但在拉格朗日这里，原函数是应予微分的、的确定的代数表示式；因此，如果或f（a）=*，那末*是原函数，4是一阶导函数等等。所以为避免混乱起见，应把因变数或者f（）称为x的函数，而相反地把拉格朗日意义下的原函数称为用x表达的原函数，并相应地把那些“导”函数称为用x表达的“导”函数。

在代数方法中，我们首先演化出预先导函数或有限差值之比产，而后才由此导出最终导函数。在这个方法中我们一开始就知道：f（a）=，所以a）4f（）=4y，因而反过来4y=4（）。于是首先要演化的，恰怡是4f（a），即f（a）的有限差值。

我们求得：

f²（）=By.

福，所以y=f²（a）。

40因而也得：

Ay=f²（x）A，并且由于4y=4f（），所以

Af（x）=f²（3）w.这微分表示式的进一步演化，给我们最后提供了

af（a）=f²（)aa它不过是以前演化得到的有限差值的微分表示式而已。

在普通方法中，

dy或df（a）=f²（a）d根本不是演化得来的，而是如上所见，只是把由二项式（+4）或（+da）完全现成地提供的（）从它的因子和相邻各项那里解脱出来。达兰贝尔方法分析

关于极限I）²a）（x+h)²=a²+3hx²+3h²a+h²，1b）（+h）=-²=3²h+3xh²+h²

（00+h）-a²

=3a²+3ch+h²。C）

店如果h变为=0，那末

2²c3

0

dy（0+0）-

而其右边=3a²，因此或

或

0

00

dy

352

y=a²,y=c2-y=0-a²=(x-①）(++²）

dy²++²或13一3

dy3x²

daII）如果我们令-=h，那末1>（-0）+3C+a²）=h（①++①²）2）因此

yy=a+a+a²。

h在1）中，的系数不是象上面那样的现成导函数，而是

dyf所以用A去除两边，给出的也不是，而是

型或AV=++a²

43

h

等等，等等。

如果在lc）的另一边，即在

f（x+h）-f（c）一或=3²+3h+h²

A

A中，我们从这样一种想象出发，以为右边h的值越减少，3xh+h²这两项的值就会越加减少，因而整个右边的值3元*+3h+h也就越来越接近于值3²；那末我们必须补充一句：无论什么时候都不会同它相吻合。

这样，3*就成为级数3*+3ch+h能够不断接近，但永远不能达到，因而更不能超过的一个值。在这个意义下，3*变成级数3*+3ch+h²的极限值。

另一方面，量（或

也将随着分母h的减少h

3:一3而越来越减少。但因是3²+3xh+N°的等价物，所以这

h

一级数的极限值就是它本身的极限值，正象在同样意义下这个L！C

极限值就是与它等价的级数的极限值一样。

但是一旦我们令=0，那末右边的各项就此消失，而使3111111111

成为右边的值的极限；3现在是的一阶导函数，因而=f

（）。作为f（x）它表明：从它又可以导出f（）（在当前情况下1

=6）等等；因而增量f（）或3*不等于从展开f（）=而得到的那些增量之和。假如f（）本身是一个无穷级数，那末从它展开而得到的增量的级数自然也是无穷级数。而在这个意义下，

5一旦我把展开得来的增量的级数截断，就变为它的展开的极限

值，从而在这里就变为一个通常代数或通常算术意义下的极限值，正如一个无限十进位小数的展开部分是它可能的展开的极限，是一个在实践或理论中够用了的极限。这和第一种意义下的极限值绝对没有共同之处。

在这里第二种意义下的极限值可以随意使之增大，而在那里则只能减少。再者，只要无在减少，

3-39:-3无

T:-3只会接近于表示式0

0；后者是它永远达不到而更不能超过的极

0看作是它的极限值。限，在这情况下可以把号看作是它的极限值。

0看作是它的极限值。但是一且变为9-dy，后者就不再是当的极

0dah

店限值，因为它自己在本身的极限中已消失了。关于它先前的形

C是它的绝对最小表示式，式4或9二，我们只能说，0是它的绝对最小表示式，

3-0

龙孤立地看，这个绝对最小表示式不是一个数值表示式；但是现在号（或器）有3m即（=）在共对再作为它的实在等份物。

ag这样一来，在等式

da0（或器）

（0）的两边，没有一边是另一边的极限值。它们之间没有极限关系而有等价关系。

6的极限，亦非G

6=2，那末既非2是3如果我有

3是2

3的极限。一个量的值=它的值的极限这种说法，只能导致淡而无味的同义反复。

因此，极限值概念是可能被曲解的，而且经常被曲解。应用到微分等式时，它作为准备令：-或h=0的、并使之成为更能想象的手段，是一种幼稚行为，这种行为来源于最初神秘的和故弄玄虚的微分演算方法。

在微分等式对曲线等等的应用中，极限值概念确实起着几何上直观化的作用

达兰贝尔方法和代数方法的比较我们把达兰贝尔方法同代数方法作一比较。I）f（）或y=²a）f（+h)或y=（0+h）²=a²+3a²h+3ah²+h²b）f（+h）-f（)或y-=3x²h+3xh²+h²

f（x+h）-f（x）或=3²+3h+h²，C

花

h当h=0时，

0元dy=3a²=f²（)。

8或器=3a²=f²（)。d）Ⅱ）f（）或y=²，a）f（）或=，b)f（x）-f（a）或y-3=x-²=（-）（x²++²）

f（x:）-.f（x）或4二2+0+²。C）

31-3+0+²。

3:-3如果变为=，那末-=0，因此

dy=（²++2²）=3²。

0或da1）

0

在两种方法中，这样一点是相同的：如果自变数增长，那末因变数也增长。整个问题在于如何表示的增长。如果变为那末-=4=h（这是一个不确定的、可以无限缩小而总是有限的差值）。

4或h是增长的增量，因为a）=3+4，但也可以反过来b）+或+h=。

历更上微分演算是从a）出发的，也就是说从下面一点出发的：差值4或增量（两者都表示同一个东西，一个是否定地作为差值4，另一个是肯定地作为增量）在量x的旁边独立地存在着，它就是的增量，表示已增长，而且增长了。出此一开始就得到了好处，那就是一且这个变数增长，那末相应于这个一般表示式的变数的原函数，就可用一定靠次的二项式来表示，因而二项式定理一开始就可应用于它。事实上在一般的一边即左边，我们已经有一个二项式，即+4或=etc.。

神秘的微分演算立刻把（+）变为（+da），或者在牛顿那里变为+。这样一来，我们在右边即代数的一边也立刻得到了用+d或+表达的二项式，而后它们就被当作普通的二项式来处理。把4变为d或的这种做法，数学上不加拒绝而先验地①假定下来，因此后来就有可能把二项式展开的一些项神秘地镇压掉。

达兰贝尔从（+da）出发，但是他把这表示式改正成为（+）或者（+h）；现在需要有一个便4或h变为d的演化，而这也就是实际所发生的全部演化。

不管是错误地从（+d）出发，还是正确地从（+h）出发，把这个不定二项式代入少的给定的代数函数中，它就变为一个具有一定靠次的二项式，犹如在Ia）中代替出现了（+h）*，并且实际上就变为这样一个二项式，它在一种情况下以d而在另一种情况下以无作为它的后一项，因而在展开中也只是作①“先验地”一词，原文为apriori。为因子外在地依附于那些通过二项式导出的函数。

因此我们在1a）中立刻现成地找到了的一阶导函数，它就是3²，就是级数第二项中附有h的系数。从此以后，3²=（）就不再改变。它本身决不是由任何一种微分过程推导得来的，而是一升始就由二项式定理所提供的，并且这确实是由于我们一开始就把增长了的表示为二项式

+=x+h即表示为增长了的。现在的整个课题，就在于使这个似乎不是处于发育之中的而是完全现成的f（），从它的因子A及其他各附带项那重摆脱出来。

在la）中则与此相反，增长了的进入代数函数在形式上完全象原先进入其中一样；”变为。通过相继的2次，而且是两次性质完全不同的微分运算，才能最后得到导函数f（）。

在等式Ib）中，差值f（+h）-f（）或y-3的确为符号微系数的形成做好了准备；对于实在微系数，这个差值只是便它从级数的第二位移到第一位，因而使它得以从无那里解放出来，此外没有任何改变。

在Ib）中，我们两边都得到差值表示式；在代数的一边，对差值作这样的演化，便得（-）作为因子出现在一个用和表达的导函数的旁边，而这个导函数是用-去除好-得来的。只有差值-存在，才有可能把它分解成两个因子。由于

-3=h，所以-分解成的两个因子也可以写成h（x++）。这表明了与Ib）的一个新的差别。h本身作为预先导函数的因子，只是通过差值-演化为两个因子的乘积才被推导出来的；而h作为“导函数”的因子，如在Ia）中那样，则是在任何一个差值形成以前就已现成地存在着的。至子从变到，的不是增长采取与并列的因子A这种分离的形式，在D中一开始就被假定了下来，在I中则是（由于-=h）通过推导而得到证明的。在D中虽然一方面是不确定的，但另一方面，就的不定增长已显现为一个固有的量，就增长了这样一个量，因而它能和并列地出现而论，却又是确定的。

在lc）中，现在要把f（）从它的因子h那里解放出来；这样，我们在左边得到或f（+h）-f（0），因而也得到微

h

h系数的一个仍然有限的表示式。但另一方面，当我们把h=0代

ody时，我们在Id）中一边入f（x+h）-f（x）

从而使它变为0-00时，我们在Id）中一边店

时，我们在Id）中一边得到符号微系数，另一边得到f（），它在la）中已现成地存在，而现在则摆脱了其余各项而单独地出现在右边。

积极的演化只发生在左边，因为符号微系数是在这里产生出来的。在右边，这个演化仅仅在于使la）中已通过二项式找到的f（）=3*，从它原先的附属物那里解放出来。h变为0或-=0在右边只具有这种消极的意义。

在llc）中则与此相反，通过：-a（=h）除两边，首先得到一个预先导函数。

最后在Id）中，由于肯定地令=，就得到最终导函数。然而这个=同时意味着令：-=0，因而使左边有限的比值

dy

C3-3交为或品。30:一8

在D中象在神秘的微分法中一样，“导函数”很少是通过令-=0或h=0而找到的。在这两种情况中都是为一开始就现成地出现的f（）扫除掉附带的各项。不过，现在数学上是正确的，而在那里则采取了一次政变。

描述：


注释：

