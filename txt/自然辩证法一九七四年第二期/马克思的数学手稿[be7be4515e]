id: be7be4515e
标题：马克思的数学手稿
日期：1881-0-0
是否是时间段：false
作者：马克思
来源：
标签：
书籍：自然辩证法一九七四年第二期
书籍作者：恩格斯，人民出版社1971年版

正文：
马克思的数学手稿

导函数的概念

I如果自变数增加到②，那末因变数就增加利g。

在这里，我们将研究只以一次幕出现的这种最简单的情况。

1）g=a；如果增加到，那末

g=aa以及y-g=a(x-）。

如果现在进行微分运算，也就是说，我们让减少到，那末

3=x3-30=0。因市

a（x-3）=a-0=0。再者，只是由于变为1，才变为g的，所以现在同样有

=y；-y=0。因而

y-y=a(x-3）①恩格斯在《反杜林论》中说，马克思遗留下一部极其重要的数学手稿。现在刊登的是其中的两篇论文：《导函数的概念》和《论微分》，系据德文原文译出。1881年，马克思把这两篇论文寄给了恩格斯。正文的两个标题以及正文下边的附注，都是译者加的。②在原稿中，变数，变化后的值记作，，现均改为，3。变为=0。

先设差值，而后文把它扬弃，这种做法从字面上看来将导致虚无。在理解微分运算时所遇到的全部困难（就象一般理解否定的否定时一样），正在于要弄清楚它是怎样区别于这种简单的运算过程，以及怎样由此导出实际结果的。

如果我们用因子-去除a（-），并相应地去除等式的左边，那末就得到

y-y=d。

:-3

由于是因变数，它根本不能进行任何独立运动，所以，在没有变=之前，就不能变为=g，因而-也就不能=0。

另一方面我们已经看到，如果不使函数a（：-）变为0，那未在函数中，就不能变为=。因此当等式的两边用因子-去除的时候，这因子必然是一个有限差值。所以在建立比值

31-3

3一a的时候，-始终是一个有限差值。由此可知，

9-9

2一3是一个有限差值之比；据此

9-9Ay

Ax

3-2所以

Ay二031-9或43二0

3一其中常数a起着两个变数的有限差值之比的极限值的作用。

由于a是常数，它不能有任何变化，所以化为这个常数的等式右边也就不能有任何变化。在这种情况下，微分过程在左边

32146工

HOaYYms

YG

heS

大一人..3

NO正X理经站

.A

D3ch

sCc

调精

无=A



如Yt

con

电C花

大c

高人

um

ieDnSue2=x

2

Hx

OukCa

3

子技·业马克思《导函数的概念》手稿的第一页

（截记系原稿保存单位加的）

Aygi-g或

3:一3或进行，这是a这类简单函数的特点。

如果在这个比值的分母中减少，那末它将超近于；一旦：变为，它就达到了减少的极限。这样一来，就使差值-=-=0，从而g-g也就=-=0。这样我们就得到

0=lo

0=lo由于在奇这个表示式中，C的来源和意义的任何痕迹都已

1的来源和意义的任何痕迹都已消失，所以我们代之以器，其中有限差值动一“或4以及9一9或4，都作为扬弃了的或消失了的差值而以符号化的形式出现，

多变成了器。因面或者说

2a10

dy=ao

dae一些唯理的数学家们，固执地认为dg和d在量上实际只

210只是接近于。

。正如在I中将要更加清楚地是无限小，指出的那样，他们借此聊以自慰只是幻想。

4y=a以及

对这里已考察的情况，还要提及的一个特点是：2各同样也=a，因而有限差值[之比了的极限值，同时也是微分da[之比了的极限值。

2）同一情况的第二个例子是；



33-y=3-3g

！=a①方括号内的文字是译者加的。下同。Ay=1

dy三1

C91-3或=1

或三13-3

I

由于y=f（w），而的函数又是以展开的代数表示式处于等式的右边，所以我们称这个表示式为x的原函数，称通过取差值而得到的初次变形为x的预先“导”函数，把通过微分过程最终得到的形式称为x的“导”函数。

1）g=aa²+bx²+ca-e。如果增加到，那末

y=a+bx²+ca-ey-y=a(a-2²)+b（x²-x²)+c(x-)=

-a(x-3）（x²+3+x²）+b（x-x）（x+x）+c(x-3）。因此

=a（+2+²）+b（x+x）+3-9或

3-3或预先“导函数”

a（²+3+x²)+b（x+3)+C在这里是有限差值之比的极限值，就是说，不管这些差值取得

名的值总是由这个“导函数”给定的。但是和I中情况多么小，不同，在这里这个值与微分之比的极限值不相同①。

如果在函数

（x²+3+2²)+b（x+2）+（①在这篇论文的草稿中接着写道

“另一方面，现在微分过程在的预先“导”函数中（右边）进行，而同一个过程必然在左边伴随着这个运动”。中，变数减少，直到其减少的极限，也就是变为等于，那末变为²，变为²，以及+a变为2，从而我们得到的“导”函数

3aa²+2bx+c。这里令人信服地表明；

第一，为了得到“导函数”，就必须令：=，所以是严格数学意义上的-=0，而无需任何只是无限接近之类的通辞。

第二，由于令=，于是-=0。这样一来，就根本没有什么符号性的东西进入“导函数”①。原先通过的变化而引入的那个量并没有消失，它只是减少到了它的最小极限值=，并且始终是。的原函数中新引进的元素，它通过部分地和自身相结合，部分地和原函数中的相结合，给出了最终“导函数”，也就是给出了减少到它的最小量的预先“导函数”。

在最初的（预先）“导”函数中，把减少到，使左边的出交为号或器，因面

dy42

0=3a²+2bx+0

0或7所以，导函数显现为微分之比的极限值

先验的②或符号性的不幸只发生在左边，但由于它现在只①在草稿中写着下列句子：“b）从的原函数找出“导函数”的过程是这样进行的：我们先着手建立一个有

Ay的极限值。我们随后进行的·限差值；这给我们提供了一个预先“导函数”，它是的极限值。我们随后进行的微分过程，就是把这个极限值减少到它的最小置。在最初的差值中所引入的量并没有消失…....”。②“先验的”一词，原文为trangzendentale。

(）铁

3RO

广大5aaDUCE

事足SB来feoDUCE

6y

An

H449欢

0（L

B230

13



LNC

8



e南京

欢车酒Cek

中8

06

电话电

P

上限店



MiL



CaaauLEu3K

CL

A

马克思《导函数的概念》手稿的第四页是作为一种过程的表示式，它的实际内容早已在等式的右边得到见证，所以已经失掉了它吓人的姿态。

在“导函数”

3aa²+2ba+C中，存在着与原函数（即与aa+6²+c-e）中的完全不同条件下的变数。所以“导函数”本身又可以作为一个原函数出现，并且通过再一次的微分过程变成另一个“导函数”的母体。只要变数并没有从某一个“导函数”中被干脆除掉，那末这种做法就可以一再重复，所以对那些只能用无穷级数表示的的函数来说，这种做法可以无限地继续下去。大多数情况都是如此

特号，等等只表明系初给定的的原函教的“导明

99，934数”系谱。一旦人们把这些符号当作运动的出发点，而不把它们当作单纯的的逐次导函数的表示式看待时，它们就变得神秘了。这确实显得很奇怪，怎么消失了的量的比值还得重新经历再次的消失呢？但是，警如象3能够同它的母体一样经历一次微分过程，那末这就一点也没有什么奇怪了。人们本来就可以从3°出发，把它当作的原函数看待。

但是必须注意，事实上只有象在I中仅以一次暴出现的

23那些等式里，云才是微分过程的结局。可是在这里，正如I中所已指出的那样，结果是

Ay=a=dy4=a=dy

da。所以，在这里通过云所经历的微分过程，实际上并没有找

du保持为某个实在过程的符号时，才有可能找到新的极只有当云保持为某个实在过程的符号时，才有可能找到新的极限值①。

dydy

当然，在微分演算中，这决不妨碍符号，a等等及其组合也能构成等式的右边。但这时人们也知道，这种纯粹符号的等式，仅仅表明以后对变数的实际函数应进行的那些运算

2）g=a”如果变到，那末y=a，以及

y-g=a(-3”）=

=a(x-2)（x-1+3-²+-²²+etc,②）

直到“a”-1这一项）。因而

g-g或=a(++++）。

Ax

2一3

如果我们现在把微分过程应用到这个“预先导函数”上，以致

3=3或2-3=0那末

x71变为a-1；²变为a-²=-2+1=3-1

c2变为-²=-3+=-1而最后

2m-a-1变为m-a-1=30+m-1=3”-1①在草稿中上面这句话是这样写的：“这只能发生在这种地方，那里预先“导”函数含有变数，因而也能通过它的运

dy动构成一个真正的新值，因而等是某个实在过程的符号。”②“etc.”表示“等等”。

这样我们就m次地获得了函数”-，因而“导函数”便是maam-

在“预先导函数”中，通过令a=，左边的器就变为或

40就变为或花，因而a，因而

dy

mdam-f

（3

微分学的所有运算都可按这种方式来处理，但那是毫无用处的烦项。不过，这里还是要举一个例子，因为在运今所举的各例中，差值-在的函数中只出现一次，因而在构成

老子成名

x一2时，它就从右边消失了。在下面的例子中就不是这种情况

3）g=a²；如果变到，那末

数=a”因此

y-y=a²a²=a²(a²-=-1）。

a²-*=1+（a-1）F'并且

+（a-1）²=1+(2-a）（a-1)+

（x-2）(x-=-1）（a-1)²+cto，

1.2因而

9-y=a²(a²--1)=a²（xi-3)（a-1）+（2-）（x--1）（a-1)²+

1.2（-2）（x--1）（=-=-2）（a-1)²+cto

1.2.3y-9或4u

（(-1)+-2-1（a-1)²+。

A3

22一3

（xi-x-1）（x-3-2）

-1）3+etc

1.2.3如果现在=，因而-=0，那末我们便得到“导函数

（a-1）-.（a-1）²+

.（a-1）²+

m-1)3-etc因前

da=a”（a-1）（a-1)²+

et

1如果我们称花括号中的常数之和为4，那末

dy=Aa²

da但是这个A=底数a①的耐普尔对数，所以

2，或当用v的值代入时da”

10ga·a

dac

2o以及

da*= loga·aidx。补充

1）以前曾经研究过这样的情况：因子（x-）在“预先导函数”中，即在有限差值等式中只出现一次。所以通过两边除以-3构成

2uy-3或A83一3这个因子便从的函数中被消去了。

2）（在例子d（a*）中）研究过这样的情况：在构成器

张之后，因子（-）还保留在的函数中。

3）还要研究一下这种情况：因子-不是直接从（“预先导函数”的）最初差值等式中演化出来的。

y=√a²+32

y=Va2+

y-g=a²+²-a²+c2我们用-去除的函数，因而也用它去除左边。于是

a²+-√a²+x²

Ayg-y或面

21一3

-

为了把根式从分子中消掉，分子和分母都用√a++√a+去乘，得

a²+x²-（a²+3²）Ay

（x-x)（√a²+32+√a²+ac²）4元

2一22

（x-30）(√a²+3²+√a²+C²）但是

332C（2-2)（√a²+2²+<a²+3C²）

（x-3)（x+x）（x-3)(√a²+x²+√a²+c²）论微分

I

1）设要加以微分的是f（）或=az。和2是自变数的两个函数；而相对于依赖它们的函数来说，它们又是自变数。因此也依赖于。

y=²，

9-y=²-=x(-)+(z-2），二或我213一3

Ay

2AA

一一说

4

A

21一3

31一3

如果在右边变为=，因而-=0，那末-=0，2-2=0，所以z二中的因子z也就变为，最后在左边

3.一定y-y=0。因此：

dy

du

dzA）

dao

da

da用各项的公分母da乘这个等式，它就变为

B)dy或d（uz)=adu+udz。2）先来研究等式A）

dy

du

dz

说dx。da

da

在只有一个依赖于的因变数的那些等式中，最后结果总是

du=f²（3），da而在f（）这个f（）的一阶导函数中，不出现任何符号表示式。例如，当”为自变数的原函数时，mx就是这样。为了把f（）变为f（），它必须经历微分过程；正是由于这种微分过程，债得f（）的化身各或器作为符号等价物在无边，即在实在微系致f（）的对面跳了出米。另一方面，号或也就在/（）

那里找到了自己的实在等价物。

在等式A）中则相反，2的一阶导函数f（）本身就包含有符号微系数，因此两边都出现符号微系数而任何一边都不是实在值。但是，由于处理2的方法和以前处理只有一个自变数的函数的方法是一样的，因此结果上的这种明显差异，显然来源于起始函数即az本身的特殊性质。关于这方面详见3）。

但是，还要先研究一下在等式A）的推导中有没有问题。在等式的右边，由于=，以及-a=0，所以

Au和3一2让-元或A6

2一元或4

A3

3一3就变成了，。但是，我们不假息索地用dnda代替0

daeda

0：0。是否允许这样做呢？问题在于两个。在这里分别作为变数和z的乘数；而在只有一个因变数的情况下，所得出的唯一

du除了常数1以外是没有任何其C

或除了常数1以外是没有任何其的符号微系数他乘数的。

dud2的原来的关键性形式代入右边，那末

如果我们把dacdae的原来的关键性形式代入右边，那末右边便变为C

+00

0。储若我们分别用伴随着和的的

2分子去乘和时，那就会得到0

03而由于变数和本身已变成了=0，所以它们的导函数也是这样，因而最后：

dz

du+W

C=0而不是+W然而这个演算过程在数学上是错误的。例如，我们取

Ai一a

3:-aA人们不是首先得到分子=0，因为这样就要从设-=0出发；而只是因为分母，即自变量的差值，亦即-变为=0，分子或-才变为=0。

，在这个形式

所以变数和2所面临的不是0，而是中它的分子始终不能和它的分母分开。因此作为乘数的，只有当

0

0时，才能使它的系数变成0。

即使在普通代数学中，如果一个乘积P·当采取了P0

0的形式，就不假思索地作出结论说它必须是=0，这也是错误的。虽然它总可以被置为=0，因为我们可以任意地从分子或分母出发来使它变成零。

如果=a²，因而²-a²=0，那末便得例如P.-a²

3-a

这个可以置为=0。因为号可以象它等于任何到P，010

O

02其他数一样，也可以等于0。

反之，如果把-a分解因子，那末我们得到P.-.（a+a)=p（a+a)，并由于a²=a²，[它又]=2Pa。

3一0逐次微分表明，只有在完全确定的条件下，才会变为=0。例如的逐次微分，在第三次求导中变数完全消失而代之以一个常数之后，第四次求导才使音变成=0。

C的来源分别是差但是在我们的情况中，已知这些C

0°O的来源分别是差值表示式AAu

，，所以一开始也理应给它们穿上制服dz

dacduda。

3）在以前讨论过的等式如g=”，g=a*等等中，处在x的原函数对面的是依赖于的“因变数”。

g=2的两边都为“因变数”所占据。如果说g直接依赖于a和，那末a和2则又依赖于。原函数2的这种特殊性质，必然也要给它的“导函数”打上自己的烙印。

是的一个函数，而2是的另一个函数，这可表示为：

=f（c），a-a=f（x）-f（3）

2=0(x），2-2=p(x:）-（x）。

但是起始等式[g=2]并没有为f（）和（）提供的原函数，也就是没有给出用表达的确定值。因此，和2只不过是依赖于的一些函数的名称和符号；所以通过对z的求导过程首先所能得出的，也不过是这个依赖关系的一般形式f（:）-f（）

9（x+）-0（）

ｌi-a

3:一3

一2

2:一3

3一3如果这个过程达到了令=因而-=0这样一点，那末这些一般形式就变为：

da

do（x）dudf（x）da

da

da

dxd

dz就作为符号微系数在“导函数”中出现了。于是，

dada就作为符号微系数在“导函数”中出现了。

di

，同这里的元，

然而在只有一个因变数的那些等式中的dud名相比，丝毫没有什么不同的内容。它也不过是de相比，丝毫没有什么不同的内容。它也不过是

y-y-f（x）-f（）

2一3

31一2的符号微分表示式。

da出现在导函数本身之内，也就是虽然符号微系数du

aadr出现在导函数本身之内，也就是出现在微分等式的右边，它们的性质决不会改变，但是它们的作用以及等式的特性却会因此而发生变化。

如果我们一般地用f（）表示原函数，f（）就表示它的一阶“导函数”，那末

dy

du十花dedx

da

dx就显现为

dy=f²（x）。

dx=f²（x）。对于只有一个因变数的等式，我们得到与此相同的一般形

学这个[作为微分演算的]起始形式都是式。在这两种情况下，在把f（）变为f（）的求导过程中产生出来的。所以，一旦f（）变为f（），那末-名就作为f（x）特有的符号表示式，作为它的

da化身或符号等价物，出现在它的对面。

，都扮演着同一个角色。因此在这两种情况下，dudz

器，二则不一样。它们包含在f（x）中，并和其他元素一道，找到了2作为自己的符号表示式或者符号等价物。但它们

do本身没有与之相对的f（），（），而实际上却是.f（），（）的符号化身。它们生来是片面的，是没有实体的阴影，是没有实在微系数的符号微系数，也就是没有相应等价“导函数”的符号微系数。这样，符号微系数便成了独立出发点，而它的实在等价物却还有待于去寻找。所以主动性就从右边代数的一端移到了左边符号的一端。然而这样一来，微分演算也就表现为一种特殊的计算方法，这种计算方法早已独立地在它固有的地盘上运用了。

dad2因为这种演算的出发点和是仅属微分演算的、并表示其特性的数学量。这种方法上的转变，在这里是作为2的代数微分的结果而得出的。代数方法就自动地转变为与它对立的微分方法①。①在这篇论文的草稿中，这一段话是这样写的：adul dz

，器则相反。它们产生于导函数之内，并和导函数中的其余元素一道，找到dy作为自己固有的符号表示式，从而找到了它们的符号等价物。它们本身是存在da作为自己固有的符号表示式，从而找到了它们的符号等价物。它们本身是存在的，但却没有等价的、实际的微系数，也就是说，没有导函数f（），（），而实际上它们是f（），g（）的符号表示式。它们都是一些现成的微分符号，其实在值表现为还有待去找的实体的阴影。所以问题就被悄俏地题倒了过来。符号微系数变成了独立的出发点，而它的等价物，实际的微系数或相应的导函数倒还有待去寻找。这样一来，主动性便从右端移到了左端。由子这个方法上的转变是从函数z的代数运动中发生的，所以它本身是被代数地论证的”。

dudz相应的“导函数”是什么呢？起

那末与符号微系数daeda相应的“导函数”是什么呢？起始等式g=az没有为解决这个问题提供任何资料。可是，如果我们用任意的的原函数来代替和，例如：

=²，=a²+aa²那末这个问题总是可以回答的。

dudz也就立刻变为运算符号，

但这样一来，符号微系数dad也就立刻变为运算符号，即对*和+a²求“导函数”可以实行的过程的符号。符号微系数原先是作为“导函数”的符号表示式，因而是已经实行了微分运算的符号表示式而产生的，现在却起着还有待于去实行的微分运算的符号的作用

同时，等式

du+礼dzdy，名dadac

da变成了一般的符号运算等式。因为两边都有符号，所以它一开始就纯粹是符号性的。

我还要提到一点，从十八世纪初直到今天，微分演算的一般课题通常是这样表述的：要给符号微系数找出实在等价物。

4）

d+dz

dyA

dx+dz

da。

da

这显然不是等式A）的最简单表示式，因为它的各项都有共同的分母d。去掉这个分母后就得到：

B）d（az）或dg=ada+adz。在B）中，它来源于A）的任何痕迹都已消失。所以B）既适用何关系而只是相互依赖的情况。它一开始就是一个符号等式，并且一开始就能作为一个符号运算等式来使用。在后一种情况下它表明，如果

y=zuetc.，即等于任意多个变数的乘积，那末dg=一些乘积之和，在这些乘积中我们依次把其中的一个因子作为变数，而把其余因子作为常数来处理。

就我们进一步研究的微分的目的而言，形式B）却并不适合。因此，如果令

=3²，=a+aa²那末正象以前在只有一个因变数的等式中所已证实了的那样，

du=4ac²da，dz=(3a²+2aa)da。把du，dz的这些值代入等式A）中，则

=（x²+a)43da+x（3²+2a)d

；所以A）dae

da

da=（+3+2）

da因而

dy=（x3+aa²）4a3+3c+(3x²+2aa)da花括号中的表示式是z的一阶导函数；但是由于az=f（a），它的导函数就=f（）；如果我们把f（）放在代数函数的位置上，那末就有

dy=f²（a)da。

我们已经从只有一个因变数的任意等式中得到了同样的结果，例如：9=”d=ma"-1=f²（x）dlae

dy=f’（a)da。一般地我们就有：如果y=f（），那末无论这个的函数是一个用表达的原函数，或者它还含有因变数，总是dg=df（）以及af（x)=f²（x)da。因而：

B）dg=f（）da是g的微分的普遍形式。即使所给的函数是f（，），也就是两个互不依赖的变数的一个函数，这也是可以立刻予以证明的。但是对于我们的目的来说，这是多余的。

H1）微分

dy=f'（x)d比导出它来的微系数

d=f（x）

da一开始就显得更为可疑。

奖=中，分母和分子不可分地联系在一起，而在

在品=0dy=f（）da中它们显然是分开的，以致只能得出这样一个结论；它无非是给“毫无办法”O的

0=f（）.0或0=0戴上了假面具的一个表示式1“毫无办法”一词，原文为“nixzewolle”。

十九世纪头三分之一年代里的一位法国数学家布夏拉，和那位熟知的“文雅的”法国人完全不同，他清楚地把微分方法和拉格朗日的代数方法联结起来。他说：

如果以器=3=°为例，那末“密又称号，或者不如说它的

Cda

CLaC值3是函数y的微系数。由于是

手是代表极限3°的符号，所以dx必须总是处在d的下面，但是为了便于进行代数运算，我们电器当做普通的分数，并把等

皇=3x²当做一个普通的等式来处把临理，于是从等式中消除分母后我们得到下面的结果

dy=3ada，这个表示式叫做的微分”。

这样，为了“便于进行代数运算”，人们引进了一个分明是错误的公式，并称之为“微分”。

实际情况并不是这样环。

在音中分子不能和分母分开，这是为什么呢？因为只有两者不分开才表示一个比值，在这个情况下才表示减少到其绝对最小值的比值：

y-yf（x:）-f（）21-3

2-3其中的分子因分母变为0而变为0。如果把两个0分开，那就失去了它们作为符号的意义，失去了含义。

但是，一旦-=0获得了以da表示的那种形式，而且始终把它看作自变数的消失了的差值，因而也把dy看作的函数，即因变数？的消失了的差值；那末分母与分子分开就完全是可以允许的运算了。现在不管da放在那里，这样一种位置的改变不会影响dg跟它的关系。所以，dy=f（）da是作为

=r（）的另一种形式出现在我们面前，并且总可以变为后者。

2）微分dg=.f（）da是从A）通过直接的代数推导得来的（见1，4）。等式A）的代数推导早已表明，微分符号，在这里就是符号微系数，原来只是作为代数地完成了的微分过程的符号表示式得出的，现在必须重新转变为独立的出发点，转变为只是尚待实行的运算的符号，或者说转变为运算符号。因此用代数方法得来的符号等式，也就转变为符号运算等式。

因此，我们有双重理由把dg=.f（）da作为符号运算等式看待。对此，现在我们事前就知道，如果

y=f（a），dy=af（a），并对f（a）完成了由df（a）所指出的微分运算，那末其结果就是dy=f（a）da。最后由此得出

=o。

但也只有从微分充当演算出发点的那一时刻起，代数的微分方法的转变才告完成，因此微分演算本身就显现为一种对变量的完全独特的、专门的计算方法。

为了把这一点说清楚，我把我所应用的代数方法作一个一般性的总结。这里以f（a）来代替用表达的确定的代数表示式，并用严（）来标记“预先导函数”（见第一份手稳①），以便同最终“导函数”f（）相区别。这样，如果

f（a）=y，f（x）=yiO即《导函数的概念》这篇论文。[那末了

f（x）-f（）=y-g或△y

f（x）（x-3）=y-g或g

预先导函数f（）完全象它的因子-那样，必须包含用，和表达的表示式

Aufi（a)=y-y或

2一3或唯一的例外是：f（）是一次的原函数。

现在如果在f（）中令

2=3，因而x-3=0，那末得到：

dy

0或d

f²（x）=0或d并且最后

f（）da=dy或dy=f²（a）da。

所以？的微分是代数演化的终点；又是在自己的地盘上活动的微分演算的出发点。孤立地、不和等价物联系起来考察，g即！的微分元在这里立刻起着同在代数方法中相同的作用；da即的微分元，则起着象那里的4c一样的作用。

如果我们从

=f（o）

42中消掉分母，那末：

I）Ay=,f²（)。

与此相反，如果我们把用代数推导得来的微分演算，作为已完成的、独特的计算方法并由此出发，那末我们就直接从I）的微分表示式，即从：）dy=f'（a）da开始。

3）由于在只有一个因变数的最初等函数的代数处理中，就已经出现了微分的符号等式，所以方法上的转换比在例子

y=a中所发生的似乎可以大为简化。

最初等的函数是一次函数。它们是：

=1，因而微分ay=da。a）y=x，它给出微系数

望=1，因而又是微分

b）y=±ab；它给出微系数dady=dr

=a，因而微分dy=ad。c）y=aa；它给出微系数如果我们取最简单的情况a），那末

3=x。

=

y-或Ay=w-或。9-3或张=1；因而也有4g=4x。如果在

景中含H

43

A3

x一2=或-=0，那末；

4=1；因此d=dx。

O18或器一旦我们得到了I），即得到了名=1，那末一开始就只得

40在左边继续运算下去，因为右边是常数1。这样一来，将主动性从右边移向左边的这种方法上的转换，似乎一开始就一下子都证明了。事实上这是代数方法本身的头一个结论。

让我们仔细地研究一下这个问题。实际结果曾经是

A=1。HA3=1。

dy=1

O或d8HS0或d8

由于1）和）两者都导致同样的结果，所以我们可以任择其一。无论如何，看来令：-=0是多余的因而是任意的运算。再者，如果我们对I）从左边出发继续进行运算，由于右边已经“毫无办法”，所以就有



最后的结论势必为8=0，所以这样获得的方法是错误的。因为第一次政变①，它并没有得出什么新东西，而第二次则导致了虚无。

最后，我们从代数学知道，如果两个等式的右边相等，那未其左边也必须相等。由此得出

型型

de=但由于a以及依赖于它的g两者都是变量，所以w虽然是一个有限差值，却可以无限地缩小，换句话说，要它怎样小就可以怎样小地接近于0，也就是说变为无限小；因而依赖于它的4y也是如此。此外，由干器=，所以需实际上并不是笔无的束的

福C

Ay起着与普通差值演算不同的无限小差值之；相反，只要43起着与普通差值演算不同的无限小差值之比的作用，就是Ay的节日盛装。

A的节日盛装。但微分dg=da本身并无任何意义，或者更确切些说，它的

名时对这两个微分元所发现的那意义至多只有象我们在分析器么一些。如果我们在刚才所赋予的那个解释下采用它，那末我①“政变”原文为法文“coup”们就已经能够用微分进行许多巧妙的运算。正如ada在决定抛物线的切线影①时的作用所表明的那样。为此不需要真正地了解d，dg的本性。

4）在我转到第Ⅱ部分，即对微分演算的历史发展过程极抗要地勾划一个轮廊以前，我还要为运今所应用的代数方法再举一个例子。为了确切地说明这个方法，我把确定的函数放在左边，这一边总是主动的一边，因为我们是从左写到右的，因而一般的等式也就是：

3C+P-+etc.+T+U=0而不是

0=a+Pa-i+ctc.+T+U。

如果函数g和自变数分开在两个等式中，在第一个等式里表示为变数的函数，在第二个等式里表示为的函数，现在要求出两者共有的符号微系数。假定

3u=91）

3u²=y，于是3+a=i。2）a3+a²=；我们先处理等式1）

3-3a²=g-y

3（u²-a²)=y-g，

3（ui-a）（+a）=y-y，1亦称次切线。如下图所示，抛物线0在点P的切线影是指有向线段TQ。

3

CT

0

8r

Q3（x+w）=二或AU

Au

一说如果在左边令=，因而-a=0，那末

3（3+2）=dy

dn

dy3（2元）

du

dy

6元=dt如果我们现在将的值+a²代入，那末；3）6（²+a²）=dy

dao现在我们转到等式2），于是

3²+a²-x²-aa²=-。

（x²-3²)+a(x²-c²)=-（x-3）（x²+3+x²)+a(x-3)（x+3）=-2

Au

-或。

（x+2+²）+a(x+）=3-如果我们在左边令=，于是-=0；因而

（x²+3a+x²)+a(x+）=-du

da

d4）332+2aa=daco如果现在将3）和4）两等式相乘，则5）6（²+aa²）（3x²+2a）=dy。dndy

dada

da这样，就用代数方法找到了运算公式

dydydu

daduda有时它也适用于带有两个自变数的等式

一个在确定的函数中得到证实了的推导，可以转化为极其一般的形式，这并不是什么不可思议的事。上面的例子就说明了这一点。假定：

1）yy=f（a）

那末y=f（）

因而yi-y=f（u）-f（u）2）a=p（x）

Hi-w=p(x)-p(x）。

i=p（i），从1）中的差值得到

dy.=df（u）2-y-f（u）-f（u）

du

duui-a

-但由于df（a）=f'（a）da，所以

dy-f（u)ddu

du由此得：

dy.=f²（n）。32

du=f²（n）。从2）中的差值得到：

dudo（x）i-a-(x)-（x）

da

dx2一3

第一记但由于dp（x）=p（）da，所以

dup（x)dada

dac因此：

du4）

n（3）

dae如果我们用等式4）乘3），则

dy=f（）·p（），证毕。dy

du或da5）

du

da

Ⅱ同这第二部分的结尾，要在博物馆里查阅了约翰·兰登[的著作]之后才能续完。

飞和（译校者：复旦大学王福山、谷超豪、苏步青、陈少新、

.张开明、金若水、秦曾复，上海师范大学程其囊）

描述：


注释：

